use color_eyre::Result;

use super::{
    ast::{Expr, Stmt},
    error::SyntaxError,
    token::{Token, TokenType},
};
use std::{iter::Peekable, marker::PhantomData, result, vec::IntoIter};

/// A wrapper trait over an iterator that allows the careless advancement of an iterator.
///
/// Implementing this trait on a struct guarantees that for the duration of the implementation, the
/// iterator will always return [`Some`] If a [`None`] variant is found, then an [`unreachable`]
/// panic is invoked as [`None`] should not have been returned.
pub trait Impetuous {
    type Item;
    fn advance(&mut self) -> Self::Item;
    fn peer(&mut self) -> &Self::Item;
}

/// Indicates that [`Impetuous`] is implemented
pub struct Safe;
/// Indicates that [`Impetuous`] is not implemented
pub struct Unsafe;

/// Machinery that allows the parser to convert the tokens into an AST
pub struct Parser<State = Safe> {
    iter: Peekable<IntoIter<Token>>,
    /// In the unsafe state, there is a possibility of `iter` returning a [`None`]. When it is
    /// safe, this is impossible; [`Impetuous`] is implemented
    state: PhantomData<State>,
}

/// An enum that tells the interpreter whether parsing failed or succeded.
///
/// It returns all the errors generated by the parser, if it fails; otherwise it returns the
/// statements that it produced.
pub enum ParseResult {
    Success(Vec<Stmt>),
    Failure(Vec<color_eyre::Report>),
}

impl Impetuous for Parser<Safe> {
    type Item = Token;
    fn advance(&mut self) -> Self::Item {
        self.iter.next().map_or_else(
            || unreachable!("syntax errors were failed to be caught; reached EOF while parsing"),
            |item| item,
        )
    }

    fn peer(&mut self) -> &Self::Item {
        self.iter.peek().map_or_else(
            || unreachable!("syntax errors were failed to be caught; reached EOF while parsing"),
            |item| item,
        )
    }
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Self {
            iter: tokens.into_iter().peekable(),
            state: PhantomData::default(),
        }
    }
}

impl Parser<Safe> {
    /// Prevents error cascading (one error causing a bunch of other ones later in the program)
    ///
    /// Discards tokens until the next statement is reached. Invoked when an error is thrown while
    /// parsing. Discarded tokens were part of a statement that caused an error and therefore were
    /// most likely erroneous themselves.
    fn sync(&mut self, prev: &TokenType) -> Option<()> {
        let mut next = self.iter.next()?;

        if prev == &TokenType::Semicolon {
            return Some(());
        }

        while next.token_type != TokenType::EOF {
            match next.token_type {
                TokenType::Class
                | TokenType::Fun
                | TokenType::Var
                | TokenType::For
                | TokenType::If
                | TokenType::While
                | TokenType::Print
                | TokenType::Return => {
                    return Some(());
                }
                _ => next = self.iter.next()?,
            }
        }
        Some(())
    }

    /// Converts a stream of tokens into an abstract syntax tree that can be interpreted
    ///
    ///
    /// # Errors
    /// This functions only produces [`SyntaxError`] that describe the errors that were exhibited.
    /// Any production of errors here, aborts the interpretation procedure as to not cascade.
    ///
    /// This function should never panic as None should never be returned from the iterator.
    pub fn parse(&mut self) -> ParseResult {
        let mut statements: Vec<Result<Stmt>> = vec![];
        let mut next = self.peer();

        loop {
            match next.token_type {
                TokenType::Print => {
                    self.iter.next(); // consume print token
                    let print = match self.expression() {
                        Ok(arg) => Ok(Stmt::Print(arg)),
                        Err(err) => Err(err),
                    };
                    let semi = self.advance();

                    match semi.token_type {
                        TokenType::EOF => {
                            statements.push(Err(SyntaxError::ExpectedCharacter(
                                String::from("EOF"),
                                ';',
                            )
                            .into()));
                            break;
                        }
                        TokenType::Semicolon => (),
                        _ => {
                            statements
                                .push(Err(SyntaxError::ExpectedCharacter(semi.lexeme, ';').into()));
                        }
                    }
                    next = self.peer();
                    statements.push(print);
                }
                TokenType::EOF => break,
                _ => {
                    let expression = self.expression().map(Stmt::Expr);
                    statements.push(expression);
                    next = self.peer();
                }
            }
        }

        if statements.iter().any(result::Result::is_err) {
            ParseResult::Failure(
                statements
                    .into_iter()
                    .filter_map(result::Result::err)
                    .collect(),
            )
        } else {
            ParseResult::Success(statements.into_iter().flatten().collect())
        }
    }

    fn expression(&mut self) -> Result<Expr> {
        self.equality()
    }

    fn equality(&mut self) -> Result<Expr> {
        let mut left = self.comparison()?;
        let mut next = self.peer();

        while let TokenType::EqualEqual | TokenType::BangEqual = next.token_type {
            let operator = self.advance();
            let right = self.comparison()?;
            left = Expr::Binary(Box::new(left), operator, Box::new(right));
            next = self.peer();
        }

        Ok(left)
    }

    /// Resolves into an [`Expr::Binary`] that represents a sequence of comparisons between two
    /// literals
    fn comparison(&mut self) -> Result<Expr> {
        let mut left = self.term()?;
        let mut next = self.peer();

        while let TokenType::Greater
        | TokenType::GreaterEqual
        | TokenType::Less
        | TokenType::LessEqual = next.token_type
        {
            let operator = self.advance();
            let right = self.term()?;
            left = Expr::Binary(Box::new(left), operator, Box::new(right));
            next = self.peer();
        }

        Ok(left)
    }

    /// Resolves into an [`Expr::Binary`] that represents a sequence of additions and subtractions
    fn term(&mut self) -> Result<Expr> {
        let mut left = self.factor()?;
        let mut next = self.iter.peek().unwrap();

        while let TokenType::Plus | TokenType::Minus = next.token_type {
            let operator = self.iter.next().unwrap();
            let right = self.factor()?;
            left = Expr::Binary(Box::new(left), operator, Box::new(right));
            next = self.iter.peek().unwrap();
        }

        Ok(left)
    }

    /// Resolves into an [`Expr::Binary`] that represents a sequence of muliplications and
    /// divisions
    fn factor(&mut self) -> Result<Expr> {
        let mut left = self.unary()?;
        let mut next = self.iter.peek().unwrap();

        while let TokenType::Star | TokenType::Slash = next.token_type {
            let operator = self.iter.next().unwrap();
            let right = self.unary()?;

            left = Expr::Binary(Box::new(left), operator, Box::new(right));
            next = self.iter.peek().unwrap();
        }

        Ok(left)
    }

    /// Resolves into an [`Expr::Unary`] that represents a literal with an operator applied to it
    fn unary(&mut self) -> Result<Expr> {
        let next = self.peer();

        match next.token_type {
            TokenType::Bang | TokenType::Minus => {
                let next = self.advance();

                Ok(Expr::Unary(next, Box::new(self.unary()?)))
            }
            TokenType::Plus => {
                color_eyre::eyre::bail!("'+' cannot be used as a unary operator")
            }
            _ => self.primary(),
        }
    }

    /// Resolves into a [`Expr::Literal`] that represents, you guessed it, a literal.
    fn primary(&mut self) -> Result<Expr> {
        let next = self.peer();

        match next.token_type {
            TokenType::False
            | TokenType::True
            | TokenType::Nil
            | TokenType::Str
            | TokenType::Number => {
                let next = self.advance();
                Ok(Expr::Literal(next))
            }
            TokenType::LeftParen => {
                self.advance(); // left paren
                let expr = self.expression()?;

                let next = self.advance();
                if TokenType::RightParen == next.token_type {
                    return Ok(Expr::Grouping(Box::new(expr)));
                }

                Err(SyntaxError::ExpectedCharacter(next.lexeme, ')').into())
            }
            _ => Err(SyntaxError::NoExpression(next.clone().lexeme).into()),
        }
    }
}
